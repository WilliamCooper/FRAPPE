%% LyX 2.1.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\usepackage{varioref}
\usepackage{float}
\usepackage{booktabs}
\usepackage{fancybox}
\usepackage{calc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[unicode=true,colorlinks=true]
{hyperref}
\usepackage{breakurl}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlist}}
\newcommand{\cc}[1]{\begin{lyxlist}{Attachments:00}
\item [cc:] {#1}
\end{lyxlist}}
\newcommand{\attach}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\begin{document}
\EOLmemo 

\global\addressee={FRAPPE data-processing file}  % >>change "File" to the "To:" name desired

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{To:}}} & \the\addressee\tabularnewline
\textsf{\textsc{\textcolor{blue}{From:}}} & Al Cooper\tabularnewline
\textsf{\textsc{\textcolor{blue}{Subject:}}} & Some suggestions re FRAPPE processing for wind and pressure\tabularnewline
\end{tabular}

\bigskip

This memo discusses some studies of the wind measurements for FRAPPE
and the related corrections to pressure based on the earlier calibration
via LAMS. This version of the memo, V3, pertains to using QCFR/PSFRD as the primary sensors for calculating TASF/TASX and hence for calculating wind. This change was made, from QCF/PSFD, because the latter did not produce wind measurements that were satisfactory in reverse-heading or circle maneuvers and also, in the case of QCF, was inconsistent with other projects in its relationship to QC\_A. QCFR/PSFRD appeared to be much better in both those regards. Note, however, that because of this change the sensitivity coefficients describing angle-of-attack and sideslip use QCFR in the denominator of the pressure ratio, so calibration coefficients are slightly different and should not be used for other projects where QCF/PSFD are primary.


\section{Calibration of the angle-of-attack}

The speed run from 15:50:00 to 15:55:00 on FRAPPE flight 4 provides
good data for determining the angle-of-attack sensitivity coefficients.
The equation used for the fit is

\begin{equation}
\alpha_{ref}=\theta-\frac{w_{p}}{V}=b_{0}+b_{1}\frac{\Delta p_{\alpha}}{q}\label{eq:AOAfitEq}
\end{equation}
where $\theta=$PITCH, $w_{p}=$GGVSPD, $V=$TASX, $\Delta p_{\alpha}=$ADIFR,
and $q=$QCFR. The choice for representing $q$ is based on QCFR being
more reliable than QCR and not requiring prior pressure-defect correction
as does PSXC (the use of which introduces circularity in the calculation
because the pressure correction itself depends on angle of attack.
The left side of (\ref{eq:AOAfitEq}) is equal to the angle of attack
if the vertical wind is zero, so the use of this result depends on
the calibration maneuver being flown in air without vertical motion. 

The details of the fit results are listed below:

% <<wind-processor-function>>=
% #' @title WindProcessor
% #' @description Calculates new wind variables
% #' @details Constructs a memo with the math basis for the transformations required to calculate wind. Takes a data.frame as input and adds to that new wind variables as listed in the description above. The data.frame must contain variables TASX, ATTACK, SSLIP, GGVEW, GGVNS, VEW, VNS, THDG, ROLL, and PITCH.
% #' @author Al Cooper
% #' @export WindProcessor
% #' @import Ranadu,signal,knitr
% #' @param Data A data.frame containing these variables: TASX, ATTACK, SSLIP, GGVEW, GGVNS, GGVSPD, VEW, VNS, THDG, ROLL, and PITCH.
% #' @return The original data.frame is returned with variables WDN, WSN, WIN added to represent the calculated wind direction and speed and the vertical wind.
% WindProcessor <- function (data=Data) {
%   Cradeg <- pi/180
%   attach (data)
%   d <- data.frame ("U" = TASX)
%   d$V <- TASX * tan (SSLIP * Cradeg)
%   d$W <- TASX * tan (ATTACK * Cradeg)
%   rw <- as.matrix(d)
%   cosphi <- cos (ROLL * Cradeg)
%   sinphi <- sin (ROLL * Cradeg)
%   costheta <- cos (PITCH * Cradeg)
%   sintheta <- sin (PITCH * Cradeg)
%   cospsi <- cos (THDG * Cradeg)
%   sinpsi <- sin (THDG * Cradeg)
%   DL <- length(TASX)
%   One <- rep (1, DL)
%   Z <- rep (0, DL)
%   T1 <- aperm(array (c(One,Z,Z,Z,cosphi,-sinphi,Z,sinphi,cosphi), 
%                    dim=c(DL,3,3)))
%   T2 <- aperm(array (c (costheta,Z,sintheta,Z,One,Z,-sintheta,Z,costheta), 
%                    dim=c(DL,3,3)))
%   T3 <- aperm(array (c (cospsi,-sinpsi,Z,sinpsi,cospsi,Z,Z,Z,One), 
%                    dim=c(DL,3,3)))
%   WDN <- vector ("numeric", DL)
%   WSN <- vector ("numeric", DL)
%   WIN <- vector ("numeric", DL)
%   VNS <- zoo::na.approx (as.vector(VNS), maxgap=1000, na.rm = FALSE)
%   VEW <- zoo::na.approx (as.vector(VEW), maxgap=1000, na.rm = FALSE)
%   GGVNS <- zoo::na.approx (as.vector(GGVNS), maxgap=1000, na.rm = FALSE)
%   GGVEW <- zoo::na.approx (as.vector(GGVEW), maxgap=1000, na.rm = FALSE)
%   VNS[is.na(VNS)] <- 0
%   VEW[is.na(VEW)] <- 0
%   GGVNS[is.na(GGVNS)] <- 0
%   GGVEW[is.na(GGVEW)] <- 0
% 
%   CVEW <- ComplementaryFilter (VEW, GGVEW, 150)
%   CVNS <- ComplementaryFilter (VNS, GGVNS, 150)
%   Hlast <- 0.
% # note: tried e.g. tensor (aperm(T1), rw, 2, 2) -- fails
% #       because of size of vector that it tries to allocate
% # This works, though:
% # Y1t <- mapply(FUN="%*%", lapply(X=apply(aperm(T1), 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(aperm(rw)))
% # etc.
% # There may be a better way, though
% # apply(T1, 3, as.data.frame) produces a list, DL long, of
% # 3x3 dataframes. lapply() converts that dataframe to a matrix
% # and then mapply multiplies rw by the matrix.
% # However, the loop below is fast (typically <1 s) and the
% # following attempt to vectorize takes more than 10 times
% # as long, so this is left commented for reference.
% # system.time(
% # {Y1 <- mapply(FUN="%*%", lapply(X=apply(T1, 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(aperm(rw)))
% # Y2 <- mapply(FUN="%*%", lapply(X=apply(T2, 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(Y1))
% # Y3 <- mapply(FUN="%*%", lapply(X=apply(T3, 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(Y2))
% # WG <- aperm(matrix (c(-CVNS_GP, -CVEW_GP, CVSPD_GP), DL, 3))
% # Y4 <- Y3 + WG
% # WDG <- atan2 (Y4[2,], Y4[1,]) / Cradeg
% # WSG <- sqrt (Y4[1,]**2 + Y4[2,]**2)
% # WIG <- Y4[3,]
% # WDG[!is.na(WDG) & (WDG < 0.)] <- WDG[!is.na(WDG) & (WDG < 0.)] + 360.
% # }) 
% # here is the loop equivalent:
%   for (i in 1:DL) {
%     Y1 <- T1[,,i] %*% matrix (rw[i,], 3, 1)
%     Y2 <- T2[,,i] %*% Y1
%     Y3 <- T3[,,i] %*% Y2
%     WG <- matrix (c(-CVNS[i], -CVEW[i], GGVSPD[i]), 
%                 3, 1)
%     Y4 <- Y3 + WG
%     WDN[i] <- atan2 (Y4[2], Y4[1]) / Cradeg
%     if ((!is.na(WDN[i])) & (WDN[i] < 0.)) {
%       WDN[i] <- WDN[i] + 360.
%     }
%     WSN[i] <- sqrt (Y4[1]**2 + Y4[2]**2)
%     WIN[i] <- Y4[3]
%   }
%   detach (data)
%   data$WDN <- WDN
%   data$WSN <- WSN
%   data$WIN <- WIN
%   return (data)
% }
% 
% @





<<initialization,echo=FALSE,include=FALSE>>=

require(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:", fig.show="keep")
opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=3)
thisFileName <- "FRAPPEprocessing"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(ggplot2)
require(grid)
require(ggthemes)
require(vioplot)
require(plyr)
require(signal)
Flight <- "rf04"        
Project = "FRAPPE"
Directory <- DataDirectory()
fname = sprintf("%s%s/%s%sR.nc", Directory, Project, Project, Flight)
print(fname)
VarNames <- c("VYC","GGALT","LATC", "LONC", "PSXC", "QCXC",
              "WDC", "WSC", "GGVEW", "GGVNS", "VEW", "VNS", "TASX",
              "ADIFR", "AKRD", "SSLIP", "PITCH", "GGTRK", "PSXC",
              "ROLL", "THDG", "BDIFR", "EWX", "WIC", "GGSPD",
              "VSPD", "ATX", "PSFD", "QCF", "GGVSPD", "GGVEW", "GGVNS")
VarList <- c("VYC","GGALT","LATC", "LONC", "PSXC", "QCXC",
             "WDC", "WSC", "GGVEW", "GGVNS", "VEW", "VNS", "TASX",
             "ADIFR", "ATTACK", "SSLIP", "PITCH", "GGTRK",
             "ROLL", "THDG", "BDIFR", "EWX", "WIC", "GGSPD",
             "PSFRD", "QCFR", "PSFC", "QCFRC", "GGVEW_NVTL", "GGVNS_NVTL",
             "VSPD", "ATX", "PSFD", "QCF", "GGVSPD_NVTL", "GGVEW", "GGVNS")
Data <- getNetCDF (fname, VarList, 154400, 161000)
Data$GGVSPD <- Data$GGVSPD_NVTL
save(Data, file=sprintf ("./%s%sR.Rdata", Project, Flight))
load(file=sprintf ("./%s%sR.Rdata", Project, Flight))
Data$GGVEW <- Data$GGVEW_NVTL
Data$GGVNS <- Data$GGVNS_NVTL
ReCalWind <- function (Data) {
  Data$PITCHC <- Data$PITCH - CorrectPitch(Data)
  ## replace TAS with TAS based on PSFRD/QCFR
  Data$PSFC <- Data$PSFRD + Data$PSFRD * PCorFunction (Data$PSFRD, Data$QCFR,     Data$ATTACK, AC="C130", Sensors="R")
  Data$PSFDC <- Data$PSFD + Data$PSFD * PCorFunction (Data$PSFD, Data$QCF, Data$ATTACK, AC="C130")
  Data$QCFRC <- Data$QCFR - Data$PSFRD * PCorFunction (Data$PSFRD, Data$QCFR, Data$ATTACK, AC="C130", Sensors="R")
  Data$QCFC <- Data$QCF - Data$PSFD * PCorFunction (Data$PSFD, Data$QCF, Data$ATTACK, AC="C130")
  Data$TASX <- TrueAirspeed (MachNumber (Data$PSFC, Data$QCFRC), Data$ATX)
#   for (i in 2:length(Data$GGVEW)) {  ##### TEMPORARY TEST #####
#     Data$GGVEW[i-1] <- 0.5 * (Data$GGVEW[i-1] + Data$GGVEW[i])
#     Data$GGVNS[i-1] <- 0.5 * (Data$GGVNS[i-1] + Data$GGVNS[i])
#   }
  ## Data$THDG <- Data$THDG -0.24   ######## TEST ##########
  ## Data$TASX <- TrueAirspeed (MachNumber (Data$PSFDC, Data$QCFC), Data$ATX)
  ## Data$TASX <- Data$TASX - 0.35  # test, subtract offset found from R-circle
  Data <- WindProcessor (Data)
  Data$WDC <- Data$WDN
  Data$WSC <- Data$WSN
  Data$WIC <- Data$WIN
  return (Data)
}
## don't call this now exc as check: QCFR/PSFRD/TASX etc should be correct
# Data <- ReCalWind (Data)
# for (i in 2:length(Data$GGVEW)) {  ##### TEMPORARY TEST #####
#   Data$GGVEW[i-1] <- 0.5 * (Data$GGVEW[i-1] + Data$GGVEW[i])
#   Data$GGVNS[i-1] <- 0.5 * (Data$GGVNS[i-1] + Data$GGVNS[i])
# }
r <- setRange (Data$Time, 155000, 155500) # speed run
DataP <- Data[r,]
Valid <- (DataP$TASX > 100.)
DataV <- DataP[Valid,]

#attach(DataV)
Cradeg <- pi / 180.
Mach <- MachNumber (DataV$PSFRD, DataV$QCFR)  # uses uncorrected q, p
AOAREF <- DataV$PITCH - asin(DataV$GGVSPD/DataV$TASX) / Cradeg
AQR <- DataV$ADIFR/DataV$QCFR # basic pressure ratio for AOA
<<AOA-fit-with-summary-and-plot, fig.show='keep', fig.lp="fig:", fig.cap="\\textsl{Fit AOA vs reference AOA ($\\alpha_{ref}$) from Eq.\ 1. The orange dashed line shows the fit, for which details and coefficients are shown in the text.}", echo=FALSE, include=TRUE, size="footnotesize", digits=4>>==
#require(Hmisc, quietly = TRUE, warn.conflicts=FALSE)
DataV["AOAREF"] <- AOAREF
DataV["AQR"]    <- AQR
fmy <- lm(AOAREF~AQR, data=DataV)
SummarizeFit <- function(ft) {
  print (summary(ft)$call)
  print ("Coefficients:")
  print (summary(ft)$coefficients)
  print (sprintf ("Residual standard error: %.3f, dof=%d", summary(ft)$sigma, summary(ft)$df[2]))
  print (sprintf ("R-squared %.3f", summary(ft)$r.squared))
}
SummarizeFit(fmy)
cfr <- coefficients (fmy)
A1 <- cfr[1]+cfr[2]*AQR
DataV$A1 <- A1
#plot (AOAREF, A1, pch=16, cex=0.8, col='blue', xlab="Ref. AOA", ylab="fit AOA")
#lines (c(-3.,6.), c(-3.,6.), lty=2, lwd=3, col='darkorange')
g <- ggplot(data=DataV, aes(x=AOAREF, y=A1))
g <- g + geom_point (pch=20, col='blue')
g <- g + geom_smooth (method='lm', col='darkorange', lty=2, lwd=1.5)
g <- g + xlab("Reference AOA [deg.]") + ylab ("AOA from fit [deg.]") + theme_WAC()
print(g)
capnF3 <- "\\textsl{The sideslip attack determined from the fit, as a function of the reference angle provided by Equation (\\ref{eq:betaFunctionForm}), for the data from FRAPPE flight RF04, 154510--154650.}"

@

The standard error for the fitted values is \Sexpr{round(summary(fmy)$sigma, digits=3)}$^{\circ}$
so this is a very good fit, with correlation coefficient of about
\Sexpr{round(summary(fmy)$r.squared^0.5, digits=3)}. If instead VSPD
is used for the vertical-speed variable, the standard error is 0.116$^{\circ}$,
only slightly worse, but the coefficients change enough that using
the higher-quality GPS measurement seems preferable. These results
are also significantly different from those previously used, but the
radome has been changed on the C-130 so that may explain the change
in sensitivity coefficients.


\section{Corrections to ambient and dynamic pressure}

A correction procedure was developed previously for correcting both
dynamic and ambient pressure measurements using flights on which the
laser air motion sensor (LAMS) was operating. These are described
in \href{http://www.atmos-meas-tech.net/7/3215/2014/amt-7-3215-2014.pdf}{this paper}.%
\footnote{Atmos. Meas. Tech., 7, 3215-3231, 2014%
} However, two problems have arisen in applying those results to the
C-130 in FRAPPE. First, the radome on the C-130 was changed and this
led to apparent changes in the sensitivity coefficients for measurement
of angle of attack, as discussed in the previous section. Because
the pressure corrections in that paper were formulated in terms of
$\Delta p_{\alpha}$=ADIFR and $q_{r}=$QCR, the parameterized fit
from that paper no longer applies to the new radome. Second, because
the radome dynamic pressure QCR encounters problems with icing or
frozen lines more often than the measurement QCF from a pitot tube,
the latter is a better choice for representing angle-of-attack and
is used in the preceding section to find coefficients for calculating
angle of attack. The formula for correcting the pressures therefore
needs to be corrected to use angle of attack, to make the correction
general and not specific to one radome, and the translation from the
previous formulation needs to account for the change in underlying
variable QCF instead of QCR. 

The correction from the paper referenced above was:

\begin{equation}
\frac{\Delta p}{p}=b_{0-}^{\prime}+b_{1}^{\prime}\frac{\Delta p_{\alpha}}{\Delta q_{r}}+b_{2}^{\prime}M\label{eq:PCOReq1}
\end{equation}
where $\Delta p$ is the correction to be applied to pressure and
$M$ is the Mach number. The Mach number used in the fit was that
determined from the uncorrected measurements of ambient and dynamic
pressure, which on the C-130 were PSFD and QCF. The coefficients determined
by fitting (\vref{eq:PCOReq1}) to the corrections determined using
LAMS were \{$b^{\prime}$\} = \{0.00152, 0.0205, 0.0149\}. In the
document on \href{https://drive.google.com/file/d/0B1kIUH45ca5Ab2Z6cld1M1cydjA/view?usp=sharing}{Processing Algorithms},
this formula was transformed to a dependence on angle of attack rather
than on the pressures from the radome, leading to this representation
for the pressure correction term:\\
\begin{equation}
\frac{\Delta p}{p}=b_{0}^{*}+b_{1}^{*}\alpha+b_{2}^{*}M\label{eq:PCOReq2}
\end{equation}
where $\alpha$ is the angle of attack. The coefficients are then
\{$b^{*}$\} = \{-0.00637, 0.001366, 0.0149\} for PSFD and \{-0.00754,
0.000497, 0.0368\} for PSFRD. The same corrections apply with reversed
sign to QCF and QCFR, respectively. With the new angle of attack determined
as in Sect.~1, these results should remain valid for the new radome
and so should be applicable to FRAPPE. 


\section{Sideslip}


\subsection{Sensitivity coefficient\label{sub:Sensitivity-coefficient}}

Calibration of the sideslip angle is more difficult, both because
the equations are more complicated and because the maneuver is very
hard to fly. Ideally, the sideslip maneuver should only change yaw
angle and heading without change in roll, altitude, or angle-of-attack,
but that is impossible. These maneuvers were flown with primary attention to roll
and altitude.

For yaw maneuvers,
the calibration is based on the expectation that the horizontal wind
remains constant. The first-order equations for the east and north
components of the wind, $u$ and $v$, are:

\begin{eqnarray}
u & = & -U_{a}\sin(\psi+\beta)+u_{p}\nonumber \\
v & = & -U_{a}\cos(\psi+\beta)+v_{p}\label{eq:horizWindeqs}
\end{eqnarray}
where $U_{a}$ is the true airspeed, $\psi$ the heading, $\beta$
the sideslip angle, and $u_{p}$ and $v_{p}$ are the eastward and
northward ground-speed components of the aircraft. These two equations
lead to the following reference formula for $\beta$:

\begin{equation}
\beta^{*}=-\psi+\arctan\left(\frac{u_{p}-u}{v_{p}-v}\right)\label{eq:beta-equation}
\end{equation}
where the second term represents a correction for the change in direction
of motion of the aircraft, which is difficult to avoid in the yaw
maneuver. The measurements thus provide $\beta^{*}$, an estimate
of the sideslip during the yaw maneuvers.

There is, however, a circular component in (\ref{eq:beta-equation}) because it involves the wind components and those require $\beta$ for their measurement when sideslip changes. To reduce the feedback
from this term, the horizontal wind components $u$ and $v$ were low-pass-filtered with periods ranging from 5--30 s and the filtered values were used in (\ref{eq:beta-equation}). The wind should remain steady during the maneuver, so this reduces any false effect of the maneuver on the measurement. This made negligible difference in the fits, and the coefficients obtained were close to those in use for sideslip, so after exploring this the unfiltered values of the wind were used for the following fit. 


A relatively simple equation provided a very good fit to the measurements:

\begin{equation}
\beta^{*}=e_{0}+e_{1}\frac{\Delta p_{\beta}}{q}\label{eq:betaFunctionForm}
\end{equation}
where $\Delta p_{\beta}$ is the pressure difference between horizontally
separated pressure ports on the radome and $q$ is the dynamic pressure: 
$\Delta p_{\beta}=$BDIFR and $q=$QCFR. 

A good set of yaw maneuvers was flown on FRAPPE flight 4, 15:45:10
to 15:46:50, so measurements from that flight period will be used
to determine the relationship between the wind-sensing pressure measurements
and the change in yaw angle. The measurements from that flight segment
gave a good fit to Eq.~\ref{eq:betaFunctionForm}, with the following
fit characteristics, as plotted in Fig.\textasciitilde{}\ref{fig:sideslip}.

<<sideslip,fig.cap=capnF3, fig.align="center", echo=FALSE, include=TRUE, size='footnotesize'>>=
# sideslip calibration:

# first get filtered wind-component values:
# u <- -1. * D$WSC * sin (D$WDC*Cradeg)
# v <- -1. * D$WSC * cos (D$WDC*Cradeg)
# u <- ButterworthFilter (u, tau=30)
# v <- ButterworthFilter (v, tau=30)

r <- setRange (Data$Time, 154510,154650)

DataP <- Data[r,]
Valid <- (DataP$TASX > 100.)
DataV <- DataP[Valid,]
#attach(DataV)
Hmean <- mean(DataV$THDG)
u <- -1. * DataV$WSC * sin (DataV$WDC*Cradeg)
v <- -1. * DataV$WSC * cos (DataV$WDC*Cradeg)
#u <- ButterworthFilter(u, tau=20.)
#v <- ButterworthFilter(v, tau=20.)
# u[1:length(r1)] <- u1
# u[(length(r1)+1):length(c(r1,r2))] <- u2
# u[(length(c(r1,r2))+1):length(r)] <- u3
# v[1:length(r1)] <- v1
# v[(length(r1)+1):length(c(r1,r2))] <- v2
# v[(length(c(r1,r2))+1):length(r)] <- v3
# tauslip = 10.
# u[1:length(r1)] <- ButterworthFilter(u[1:length(r1), tau=tauslip)
# u[(length(r1)+1):length(c(r1,r2))] <- ButterworthFilter(u[(length(r1)+1):length(c(r1,r2))], tau=tauslip)
# u[(length(c(r1,r2))+1):length(r)] <- ButterworthFilter(u[(length(c(r1,r2))+1):length(r)], tau=tauslip)
# v[1:length(r1)] <- ButterworthFilter(v[1:length(r1), tau=tauslip)
# v[(length(r1)+1):length(c(r1,r2))] <- ButterworthFilter(v[(length(r1)+1):length(c(r1,r2))], tau=tauslip)
# v[(length(c(r1,r2))+1):length(r)] <- ButterworthFilter(v[(length(c(r1,r2))+1):length(r)], tau=tauslip)

SSREF <- -DataV$THDG + atan2((DataV$VEW-u), (DataV$VNS-v))/ Cradeg
SSREF[SSREF < -180.] <- SSREF[SSREF < -180.] + 360.
#plot (SSREF, SSLIP, pch=16, cex=0.6,col='blue')
BQR <- DataV$BDIFR / DataV$QCFR
DataV["SSREF"] <- SSREF
DataV["BQR"] <- BQR
sfm <- lm(SSREF~BQR, data=DataV)
cfs <- coefficients(sfm)
#print(c("Fit coefficients are: ",cfs))
#print(summary(sfm))
SummarizeFit(sfm)
S2 <- cfs[1] + cfs[2] * BQR
#plot (SSREF, S2, pch=16, cex=0.6, col='blue',
#      xlab="SS Reference", ylab="SSLIP from fit")
#lines(c(-8.,8.), c(-8.,8.), col='orange', lty=2, lwd=3)
DataV["S2"] <- S2
g <- ggplot (data=DataV, aes(x=SSREF, y=S2))
g <- g + geom_point (pch=20, col='blue') + geom_smooth (method='lm', col='darkorange', lty=2, lwd=1.5)
g <- g + xlab("Reference Value of Sideslip from (4) [deg.]") + ylab ("SSLIP from fit [deg.]")
g <- g + theme_WAC()
print (g)

@

The result from the calibration is also shown in Fig.\ 2, as the dashed orange line. The square of the correlation was exceptionally high, \Sexpr{round(summary(sfm)$r.squared,4)}, the residual standard error was \Sexpr{round(summary(sfm)$sigma, 2)}$^{\circ}$, and the best-fit coefficients were \{$e_0$, $e_1$\} = \{\Sexpr{round(cfs[1], 4)}, \Sexpr{round(cfs[2], 4)}\}. For comparison, the standard values from the calibration of the previous radome were \{-0.012, 12.21\}, so the sideslip calibration is significantly different, especially in regard to the constant or offset term, from the old calibration. However, the offset (or first term in the fitted equation) is dependent on the heading being accurate, and the heading has errors that are different for each flight and during flights. It is therefore useful to check the first coefficient in other ways, either by circle or reverse-heading maneuvers, so this coefficient will be adjusted based on the additional study of such maneuvers that follows. 



<<caption2, echo=FALSE, include=FALSE>>=
cap3panel <- "\\textsl{Wind components measured during the reverse-heading maneuver of FRAPPE flight RF04, 1558--1610. The red dashed lines indicate the straight legs before and after the turn to reverse course and show the mean values averaged over those segments. The top panel shows the longitudinal wind component, the middle panel the lateral wind component as originally processed, and the bottom panel the lateral wind with the new calibration but adjusted to eliminate the offset.}"
@


\subsection{Sideslip and heading offsets}


\subsubsection{Reverse-heading maneuvers}

A reverse-heading maneuver was flown on FRAPPE flight RF04, 160000--160245
and 160615--160815. For such a maneuver, if the wind remains constant,
the expectation is that the longitudinal and lateral components of
the wind each should reverse sign between the two legs. These components
are, approximately, 

\begin{equation}
v_{x}=v_{g}\cos(\xi-\psi)-v_{t}\label{eq:longWind}
\end{equation}
\begin{equation}
v_{y}=v_{g}\sin(\xi-\psi)-v_{t}\sin\beta\label{eq:latWind}
\end{equation}
where $v_{g}$ is the ground speed, $v_{t}$ the true airspeed, $\xi$
the ground-track angle, $\psi$ the heading, and $\beta$ the sideslip
angle. 
<<RevHFig1, include=TRUE>>=

r <- setRange(Data$Time, 155800, 161000)
DataP <- Data[r,]
## DataP$TASX <- DataP$TASX
DataP$SS <- cfs[1]+cfs[2] *  DataP$BDIFR / DataP$QCF
#attach(DataP)
Vg <- sqrt(DataP$GGVEW**2+DataP$GGVNS**2)
Vlg <- Vg*cos((DataP$GGTRK-DataP$THDG)*Cradeg)-DataP$TASX
Vlt <- Vg*sin((DataP$GGTRK-DataP$THDG)*Cradeg)-DataP$TASX*sin(DataP$SS*Cradeg)
r1 <- setRange(DataP$Time, 160000,160245)
r2 <- setRange(DataP$Time, 160615,160815)
TASmean <- mean (DataP$TASX[c(r1, r2)], na.rm=TRUE)
Vlg1 <- mean(Vlg[r1])
Vlg2 <- mean(Vlg[r2])
Vlt1 <- mean(Vlt[r1])
Vlt2 <- mean(Vlt[r2])
#print (sprintf("Longitudinal wind averages: %f %f",Vlg1,Vlg2))
#print(sprintf("Lateral wind averages:      %f %f",Vlt1,Vlt2))
#print(TASmean)
#SSLIP <- SSLIP+1.25
## 1.40 that follows was determined by best match for lateral components
SSL <- 1.40+cfs[2]*DataP$BDIFR/DataP$QCFR # rec developed earlier
Vltr <- Vg*sin((DataP$GGTRK-DataP$THDG)*Cradeg)-DataP$TASX*sin(SSL*Cradeg)
# op <- par (mfrow=c(2,1), mar=c(4,4,0,2)+0.1)
# plotWAC(DataP$Time,Vlg,ylab="Longitudinal")
# r1 <- setRange(DataP$Time, 160000,160245)
# r2 <- setRange(DataP$Time, 160615,160815)
# Vlg1 <- mean(Vlg[r1])
# Vlg2 <- mean(Vlg[r2])
# points(DataP$Time[r1], rep(Vlg1, length(r1)), type='l', lwd=3,col='red')
# points(DataP$Time[r2], rep(Vlg2, length(r2)), type='l', lwd=3,col='red')
Vlt1r <- mean(Vltr[r1])
Vlt2r <- mean(Vltr[r2])
#print (c(Vlg1,Vlg2))
#print(sprintf("Lateral wind components with new calibration: %f %f",Vlt1r,Vlt2r))
#detach(DataP)

@

These components are plotted in Fig.\ \ref{fig:actual-plot-1}, with the primary measurements considered to be PSFRD and QCFR for the calculation of true airspeed and wind as well as for the determination of sensitivity coefficients. The top panel shows that, for the longitudinal component, the reverse-course measurements change from \Sexpr{round(Vlg1, 2)} to \Sexpr{format(round(Vlg2, 2), nsmall=2)}, so the indicated error is about \Sexpr{round(-(Vlg1+Vlg2)/2, 1)} m/s. This is reasonable in comparison to the estimated 0.3 m/s uncertainty in true airspeed, as found from the original LAMS-based PCOR study and as verified in that study by a series of reverse-heading maneuvers.  The lateral measurements, shown in the middle panel, also were satisfactory: The values for the two legs were \Sexpr{round(Vlt1,2)} and \Sexpr{round(Vlt2,2)} indicating a lateral error of about \Sexpr{round((Vlt1+Vlt2)/2,1)}\,m/s. This calculation used the sensitivity coefficients as determined above (with first coefficient for the sideslip calibration 1.3793), but the agreement between the two legs is even better, indicating an error of <0.1\,m/s, if the offset is changed to 1.40$^{\circ}$. The latter result is shown in the bottom panel of  Fig.\ \ref{fig:actual-plot-1}.

When the longitudinal wind was calculated instead from QCF and PSFD, the disagreement in this reverse-heading maneuver was significantly larger, about 2.4 m/s, indicating an error in true airspeed of about 1.2 m/s. A reason for this disagreement has not been found, but comparison of QCF to QC\_A shows that this has changed from earlier projects although the similar relationship of QCFR to QC\_A has stayed consistent. This suggests a problem with the calibration of QCF, but examination of the calibration records does not indicate any problem. Nevertheless, it appears preferable to use QCFR and PSFRD as primary sensors for FRAPPE. 

<<actual-plot-1, fig.cap=cap3panel, include=TRUE, fig.height=4.8, fig.width=6.5, fig.lp="fig:">>=
op <- par (mfrow=c(3,1), mar=c(4,4,0,2)+0.1)
Z <-plotWAC(DataP$Time,Vlg,ylab="Longitudinal [m/s]")
points(DataP$Time[r1], rep(Vlg1, length(r1)), type='l', lty=2,lwd=3,col='red')
points(DataP$Time[r2], rep(Vlg2, length(r2)), type='l', lty=2,lwd=3,col='red')
Z <- plotWAC(DataP$Time, Vlt, ylab="Lateral [m/s]")
points(DataP$Time[r1], rep(Vlt1, length(r1)), type='l', lty=2,lwd=3,col='red')
points(DataP$Time[r2], rep(Vlt2, length(r2)), type='l', lty=2,lwd=3,col='red')
Z <- plotWAC(DataP$Time, Vltr, ylab="Revised Lateral [m/s]")
points(DataP$Time[r1], rep(Vlt1r, length(r1)), type='l', lty=2,lwd=3,col='red')
points(DataP$Time[r2], rep(Vlt2r, length(r2)), type='l', lty=2,lwd=3,col='red')

cap5panel <- "\\textsl{Wind components measured during the reverse-heading maneuver of FRAPPE flight 9, 193100--193910. The red dashed lines indicate the straight legs before and after the turn to reverse course and show the mean values averaged over those segments. The top panel shows the longitudinal wind component, the middle panel the lateral wind component as originally processed, and the bottom panel the lateral wind with the new calibration but adjusted to eliminate the offset.}"

@


<<RevHFig2, fig.cap=cap5panel, fig.lp="fig:", fig.height=4.8, fig.width=6.5, include=TRUE>>=

Flight <- "rf09"
fname = sprintf("%s%s/%s%sR.nc", Directory, Project, Project, Flight)
#print(fname)
#Data <- getNetCDF (fname, VarNames)
Data <- getNetCDF (fname, VarList, 191800, 194000)
Data$GGVSPD <- Data$GGVSPD_NVTL
save(Data, file=sprintf ("./%s%sR.Rdata", Project, Flight))
load(file=sprintf ("./%s%sR.Rdata", Project, Flight))
## load("/home/Data/FRAPPE/FRAPPErf09.Rdata")
## Data <- d

Data$GGVEW <- Data$GGVEW_NVTL
Data$GGVNS <- Data$GGVNS_NVTL
## Data <- ReCalWind (Data)
for (i in 2:length(Data$GGVEW)) {  ##### TEMPORARY TEST #####
  Data$GGVEW[i-1] <- 0.56 * Data$GGVEW[i-1] + 0.44 * Data$GGVEW[i]
  Data$GGVNS[i-1] <- 0.56 * Data$GGVNS[i-1] + 0.44 * Data$GGVNS[i]
}
# ## replace TAS with TAS based on PSFRD/QCFR
# Data$PSFC <- Data$PSFRD + Data$PSFRD * PCorFunction (Data$PSFRD, Data$QCFR, Data$ATTACK, AC="C130", Sensors="R")
# Data$QCFRC <- Data$QCFR - Data$PSFRD * PCorFunction (Data$PSFRD, Data$QCFR, Data$ATTACK, AC="C130", Sensors="R")
# Data$TASX <- TrueAirspeed (MachNumber (Data$PSFC, Data$QCFRC), Data$ATX)
# Data$PITCHC <- Data$PITCH - CorrectPitch(Data)
# Data <- WindProcessor (Data)
# Data$WDC <- Data$WDN
# Data$WSC <- Data$WSN
# Data$WIC <- Data$WIN
## correct for QCF cal coefficient:
# calqcf <- c(1.18249, 17.2991, -0.00421515)
# calold <- c(0.264, 17.227, 0.001)
# Volts <- (sqrt(calqcf[2]^2-4*calqcf[3]*(calqcf[1]-Data$QCF))-calqcf[2])/(2*calqcf[3])
# Data$QCFsave <- Data$QCF
# Data$QCXCsave <- Data$QCXC
# Data$QCF <- calold[3]*Volts^2 + calold[2]*Volts + calold[1]
# ## revise TAS on basis of new QCF
# Data$QCXC <- Data$QCF - PCorFunction (Data$PSF, Data$QCF, Data$AKRD, AC="C130")
# Data$PSXC <- Data$PSF + PCorFunction (Data$PSF, Data$QCF, Data$AKRD, AC="C130")
# Data$TASsave <- Data$TASX
# Data$TASX <- TrueAirspeed (MachNumber (Data$PSXC, Data$QCXC), Data$ATX)-2
# Data$GGVSPD <- Data$GGVSPD_NVTL
# Data$ATTACK <- Data$AKRD
# Dnew <- WindProcessor (Data)
# ## replace values in normal data.frame and process as before
# Data$WSC <- Dnew$WSN
# Data$WDC <- Dnew$WDN
# Data$WIC <- Dnew$WIN
# Data$TASX <- Data$TASX - 1  # test fudge
r <- setRange(Data$Time, 193100, 193910)
DataP <- Data[r,]
attach(DataP)
SS <- cfs[1] + cfs[2] * BDIFR / QCFR
Vg <- sqrt(GGVEW**2+GGVNS**2)
Vlg <- Vg*cos((GGTRK-THDG)*Cradeg)-TASX
Vlt <- Vg*sin((GGTRK-THDG)*Cradeg)-TASX*sin(SS*Cradeg)
op <- par (mfrow=c(3,1), mar=c(4,4,0,2)+0.1)
plotWAC(Time,Vlg,ylab="Longitudinal [m/s]")
r1 <- setRange(Time, 193100,193400)
r2 <- setRange(Time, 193610, 193910)
Vlg1 <- mean(Vlg[r1])
Vlg2 <- mean(Vlg[r2])
points(Time[r1], rep(Vlg1, length(r1)), type='l', lty=2,lwd=3,col='red')
points(Time[r2], rep(Vlg2, length(r2)), type='l', lty=2,lwd=3,col='red')
plotWAC(Time, Vlt, ylab="Lateral [m/s]")
Vlt1 <- mean(Vlt[r1])
Vlt2 <- mean(Vlt[r2])

Z <- points (Time[r1], rep(Vlt1, length(r1)), type='l', lty=2, lwd=3, col='red')
Z <- points (Time[r2], rep(Vlt2, length(r2)), type='l', lty=2, lwd=3, col='red')
#SSLIP <- SSLIP+1.25
#SSL <- cfs[1]+cfs[2]*BDIFR/QCF
SSL <- 1.50+cfs[2]*BDIFR/QCFR
Vlt <- Vg*sin((GGTRK-THDG)*Cradeg)-TASX*sin(SSL*Cradeg)
# op <- par (mfrow=c(2,1), mar=c(4,4,0,2)+0.1)
# plotWAC(Time,Vlg,ylab="Longitudinal")
# r1 <- setRange(Time, 160000,160245)
# r2 <- setRange(Time, 160615,160815)
# Vlg1 <- mean(Vlg[r1])
# Vlg2 <- mean(Vlg[r2])
# points(Time[r1], rep(Vlg1, length(r1)), type='l', lwd=3,col='red')
# points(Time[r2], rep(Vlg2, length(r2)), type='l', lwd=3,col='red')
Z <- plotWAC(Time, Vlt, ylab="Revised Lateral [m/s]")
Vlt1r <- mean(Vlt[r1], na.rm=TRUE)
Vlt2r <- mean(Vlt[r2], na.rm=TRUE)
#print (c(Vlg1,Vlg2))
Z <- points(Time[r1], rep(Vlt1r, length(r1)), type='l', lty=2,lwd=3,col='red')
Z <- points(Time[r2], rep(Vlt2r, length(r2)), type='l', lty=2,lwd=3,col='red')
detach(DataP)

@

The conditions were not ideal during this maneuver, however, with
important variability along each of the legs as shown in Fig.~3 and
with some mis-alignment of the two legs, so it is worthwhile to consider
other maneuvers. Another reverse-heading maneuver was flown on flight
9, with reverse legs 19:31:00--19:34:00 and 19:36:10--19:39:10. The sideslip offset determined from this maneuver is slightly larger than that from the Flight-4 maneuver, 1.50$^{\circ}$ instead of 1.40$^{\circ}$, but  as shown in Fig.~\ref{fig:RevHFig2}
the conditions were steadier for this case.   A remaining source of variability
in the sideslip offset determined in this way is error in heading,
because it is not possible to separate an offset in sideslip from
an offset in heading using reverse-heading maneuvers. Because the
heading standard uncertainty is 0.05$^{\circ}$, uncertainty at this
level also characterizes the offset in sideslip. This offset will be used for preliminary calculations in the next section, where a further refinement in the sideslip offset can be made.


<<getCircleData, include=TRUE>>=

#print (sprintf("Longitudinal wind averages: %f %f",Vlg1,Vlg2))
#print (sprintf("Lateral wind averages:      %f %f",Vlt1,Vlt2))
#print(sprintf("Lateral wind components with new calibration: %f %f",Vlt1r,Vlt2r))
require(stats) 
D <- Data[setRange (Data$Time, 191900, 192700), ]
## cfs[1] <- cfs[1] + 1.545
## the following results from the rev-heading evaluation:
cfs[1] <- 1.50
D["SS"] <- cfs[1] + cfs[2]*D$BDIFR/D$QCF
startL <- 191936
endL <- 192228
startR <- 192308
endR <- 192602
startC <- 191900
endC <- 192700
r <- setRange(D$Time, startC, endC)
r1 <- setRange(D$Time, startL, endL)
r2 <- setRange(D$Time, startR, endR)
meanr1 <- mean(D$ROLL[r1], na.rm=TRUE)
meanr2 <- mean(D$ROLL[r2], na.rm=TRUE)
sdr1 <- sd(D$ROLL[r1], na.rm=TRUE)
sdr2 <- sd(D$ROLL[r2], na.rm=TRUE)
meanv1 <- mean(D$TASX[r1], na.rm=TRUE)
meanv2 <- mean(D$TASX[r2], na.rm=TRUE)
sdv1 <- sd(D$TASX[r1], na.rm=TRUE)
sdv2 <- sd(D$TASX[r2], na.rm=TRUE)
meanv <- mean(D$TASX[c(r1,r2)])
sdv <- sd(D$TASX[c(r1,r2)])
t1 <- setRange(D$Time, startL, endL)
t2 <- setRange(D$Time, startR, endR)
Cradeg = pi/180.

@


\subsubsection{Circle maneuvers}

Another way to determine the offset in sideslip is via circle maneuvers,
in which one or more circles are flown at steady bank angle turning
one direction and then one or more additional circles are flown in
the opposite direction. The measured wind should remain constant around
such circles, so any variations can be used to isolate offsets in
true airspeed (affecting the measurement of the longitudinal component
of the wind) and offsets in sideslip or heading (affecting the measurement
of the lateral component). Two such circles were flown from 19:19--19:27
on flight 9, as shown in Fig.~\ref{fig:CircleFlightPatterns-1}. 

\begin{figure}
\begin{centering}
\includegraphics[width=0.49\textwidth]{R9circles}\includegraphics[width=0.49\textwidth]{R9circleDrift}
\par\end{centering}

\protect\caption{\textsl{Example of circle flight pattern, FRAPPE flight 9, 19:19--19:27
UTC. Left side: normal flight track; right side, flight track plotted
in a reference frame drifting with the horizontal wind.}\label{fig:CircleFlightPatterns-1}}
\end{figure}
If the wind remains steady around the turns, analyses of the measurements
can lead to these results:
\begin{enumerate}
\item Wind can be determined from the GPS-measured ground speeds and the
heading, with no other reference to the normal wind measurements.
\item Measurement of a possible bias in the true-airspeed measurement TASX:
If present, the measured windspeed will change from upwind to downwind
direction.
\item Determining biases in heading and sideslip: If present, the measured
windspeed will change from crosswind-right to crosswind-left positions.
\item An offset in sideslip can be separated from an offset in heading by
checking for the expected sign reversal in sideslip between left-turn
and right-turn circles. 
\item Departures from constant wind can be used to determine possible time
shifts, especially by comparing results from left-turn and right-turn
circles.
\end{enumerate}
Each of these will be explored in this section. To get accurate circle
patterns, it is important that the wind be relatively steady and non-turbulent
and that the roll angle be maintained constant. For this flight segment,
the left-turn circles had a roll angle of \Sexpr{round(meanr1,2)}$\pm$\Sexpr{round(sdr1,2)}
and the right-turn circles had roll angle \Sexpr{round(meanr2,2)}$\pm$\Sexpr{round(sdr2,2)},
while the mean true airspeed for these circles was \Sexpr{round(meanv,1)}$\pm$\Sexpr{round(sdv,1)}.
The steadiness of these measurements indicates that this maneuver was
flown with good precision and reasonably symmetrically, although the
difference in roll is larger than is characteristic of similar maneuvers with the GV and may indicate some trim adjustment. The mean roll angles are within
1.5$^{\circ}$ and are quite steady for each turn direction, so it
will be a reasonable approximation to assume that these patterns are
circular.

Because the circles are flown with turn rates of about 1.5$^{\circ}$/s, small errors in the timing of measurements entering the wind calculation can lead to significant errors. The primary comparison used here is to the ground-speed as provided by GPS, so the timing of that signal relative to the corresponding IRU measurements is especially critical for this analysis. As processed, the data file (FRAPPErf09R.nc) used offsets of -2000\,ms for GGVEW and GGVNS along with an offset of -80\,ms for the IRU measurements including VEW and VNS. High-rate (25\,Hz) measurements were used to study the time shifts, in two ways. First, the standard error between GGVNS and VNS, or between GGVEW and VEW, was minimized by shifting GGVNS or GGVEW in time; both comparisons gave minimum RMS errors (of about 0.1\,m/s) for a time shift of +11 25-Hz samples, or 440\,ms. Second, the heading shift discussed in the next section was used as a test of this result. Without shift in timing, the left-turn circle indicated a heading error of about +1$^{\circ}$ and the right-turn circle about -1$^{\circ}$; after timing adjustment of GGVEW/GGVNS by 440\,ms, the respective errors were -0.1$^{\circ}$ and -0.2$^{\circ}$ for the left-turn and right-turn circles. This confirmed that the dominant contribution to the error in heading was from the time-lag in GGVEW/GGVNS, which would be expected to produce opposite errors for left-turn and right-turn circles.

The indicated shift was 11 samples forward in time; i.e., GGVEW[12] was replaced by GGVEW[1]. In processing, the assumed lag was -2000\,ms (GGVEW[1] replaced by GGVEW[101]). This suggests that the time lag of -2000\,ms should be replaced by a lag of -1560\,ms, if the lag for VEW/VNS is kept at 80\,ms. A similar study of the lag applicable to the NOVATEL-GPS measurements GGVNS\_NVTL/GGVEW\_NVTL indicated that the time shift was +120\,ms, placing these measurements 200\,ms ahead of the IRU measurements. This relatively small shift probably should be ignored in processing and the lag kept at zero to avoid the awkwardness of positive lag values. 

<<plotGSRMS>>=

# define a chisquare error function:
csq <- function (x, D) {
  hdg <- (D$THDG+D$SS*cos(D$ROLL*pi/180)+x[4]) * pi / 180.
  dvx <- D$GGVEW - (x[2] + x[1]*sin(hdg))
  dvy <- D$GGVNS - (x[3] + x[1]*cos(hdg))
  chisq <- sum (dvx**2 + dvy**2)
}
# try shifting GGVxxB forward n samples
rms <- vector("numeric", 29)
GGVEW <- D$GGVEW
GGVNS <- D$GGVNS
NL <- length(D$GGVEW)
rmsmin <- 1000
#for (n in 1:1) { 
  #D$GGVNS <- c(D$GGVNS[(1+n):NL],rep(D$GGVNS[NL],n))
  #D$GGVEW <- c(D$GGVEW[(1+n):NL],rep(D$GGVEW[NL],n))
  wx <- 12.3
  wy <- 13.2
  V <- 154.
  hdg <- D$THDG * Cradeg
  A <- nlm (csq, c(V, wx, wy, -0.1), D, hessian=TRUE)
  #D$GGVEW <- GGVEW
  #D$GGVNS <- GGVNS
  #print(A$estimate)
  V <- A$estimate[1]
  wx <- A$estimate[2]
  wy <- A$estimate[3]
  dh <- A$estimate[4]
 #print(sprintf(" wind estimate: %.1f / %.1f", atan2(wy,wx)*180/pi+180, sqrt(wx**2+wy**2)))
  vx <- V * cos(hdg+dh*Cradeg) + wx
  vy <- V * sin(hdg+dh*Cradeg) + wy
  rms <- (A$minimum/length(D$THDG))**0.5
  if (rms < rmsmin) {
    rmsmin <- rms
    bestFit <- A$estimate
    #nbest <- n
  }
  #print(sprintf("RMS error for shift of %d samples: %5.2f m/s", n, rms[n]))
#}

# impose best-fit shift nbest units forward in time
#D$GGVNS <- c(D$GGVNS[(1+nbest):NL],rep(D$GGVNS[NL],nbest))
#D$GGVEW <- c(D$GGVEW[(1+nbest):NL],rep(D$GGVEW[NL],nbest))
# best-fit wind:
bestWD <- (atan2(bestFit[2], bestFit[3]) / Cradeg + 180.) %% 360
bestWS <- sqrt(bestFit[2]**2 + bestFit[3]**2)
mwd <- mean(D$WDC, na.rm=TRUE)
mws <- mean(D$WSC, na.rm=TRUE)
mtas <- mean(D$TASX, na.rm=TRUE)
D["AA"] <- (D$THDG-mwd) %% 360

@

<<getRMS>>=

hdg <- (D$THDG+bestFit[4])*Cradeg
vx <- bestFit[1] * cos(hdg) + bestFit[2]   
vy <- bestFit[1] * sin(hdg) + bestFit[3]
gs <- sqrt(D$GGVEW**2+D$GGVNS**2)
vs <- sqrt(vx**2+vy**2)
rmsgs <- (sum((gs-vs)**2)/length(gs))**0.5
# restore original values
#D$GGVNS <- GGVNS
#D$GGVEW <- GGVEW
rm (GGVEW, GGVNS)

@


\paragraph{Finding the wind from GPS only}

If it is assumed that $\bar{u_{x}}$, $\bar{u_{y}}$, TAS, and $\delta\psi$
(the two components of the horizontal wind, the true airspeed, and
an assumed error in heading) are constant, then the expected ground-speed
components will be:

\begin{align}
v_{x} & =\bar{u_{x}}+TAS\,\sin(\psi+\delta\psi)\label{eq:circle-gs-components}\\
v_{y} & =\begin{gathered}\bar{u_{y}}+TAS\,\cos(\psi+\delta\psi)\end{gathered}
\nonumber 
\end{align}
where $\psi$ is the heading. The error between these expressions
for the ground speed and the measured ground-speed components $g_{x}$
and $g_{y}$ then can be minimized to find the four constant parameters
in (\ref{eq:circle-gs-components}) using this expression as a measure
of the error:

\begin{equation}
\chi^{2}=\sum((g_{x}-v_{x})^{2}+(g_{y}-v_{y})^{2})\label{eq:gs-chisq}
\end{equation}


The resulting best-fit values, with wind converted to wind direction
$\bar{v_{d}}$ and wind speed $\bar{v_{s}}$, are shown in Table~\ref{tab:GSmin}
and plotted in Fig.~\ref{fig:PlotGSvsWSc}.

<<PlotGSvsWSc, fig.lp="fig:", fig.cap="\\textsl{The ground-speed components measured by GPS (blue line, EW; green line, NS) and the corresponding results from the fit (red dashed lines) for the period of the circle maneuver.}", include=TRUE>>=

Z <- plotWAC(D$Time, D$GGVEW, ylab="GS Component, m/s", lwd=2)
Z <- lineWAC(D$Time, D$GGVNS, col='green', lwd=2)
Z <- lineWAC(D$Time, vx, col='red',lwd=2,lty=2)
Z <- lineWAC(D$Time, vy, col='red',lwd=2,lty=2)
subtitle <- sprintf("best fit: red dashed lines")
title(main="G-EW [blue]; G-NS [green]", cex.main=0.75, sub=subtitle)


@

<<GSRMSRL, include=FALSE>>=

# define a chisquare error function:
csq <- function (x, D) {
  hdg <- (D$THDG+D$SS*cos(D$ROLL*pi/180)+x[4]) * pi / 180.
  dvx <- D$GGVEW - (x[2] + x[1]*sin(hdg))
  dvy <- D$GGVNS - (x[3] + x[1]*cos(hdg))
  chisq <- sum (dvx**2 + dvy**2)
}
DS <- D
D <- D[t1,]
NL <- length(D$GGVEW)
rmsminL <- 1000
n <- 0
# for (n in 9:29) {
#   D$GGVNS <- c(D$GGVNS[(1+n):NL],rep(D$GGVNS[NL],n))
#   D$GGVEW <- c(D$GGVEW[(1+n):NL],rep(D$GGVEW[NL],n))
  wx <- 12.3
  wy <- 13.2
  V <- 154.
  hdg <- D$THDG * Cradeg
  AL <- nlm (csq, c(V, wx, wy, -0.1), D, hessian=TRUE)
  #print(A$estimate)
  VL <- AL$estimate[1]
  wxL <- AL$estimate[2]
  wyL <- AL$estimate[3]
  dhL <- AL$estimate[4]
 #print(sprintf(" wind estimate: %.1f / %.1f", atan2(wyL,wxL)*180/pi+180, sqrt(wxL**2+wyL**2)))
  vxL <- VL * cos(hdg+dhL*Cradeg) + wxL
  vyL <- VL * sin(hdg+dhL*Cradeg) + wyL
  rmsL <- (AL$minimum/length(D$THDG))**0.5
  if (rmsL < rmsminL) {
    rmsminL <- rmsL
    bestFitL <- AL$estimate
    #nbest <- n
#   }
  #print(sprintf("RMS error for shift of %d samples: %5.2f m/s", n, rms))
}

# impose best-fit shift nbest units forward in time
# D$GGVNS <- c(D$GGVNS[(1+nbest):NL],rep(D$GGVNS[NL],nbest))
# D$GGVEW <- c(D$GGVEW[(1+nbest):NL],rep(D$GGVEW[NL],nbest))
# best-fit wind:
bestWDL <- (atan2(bestFitL[2], bestFitL[3]) / Cradeg + 180.) %% 360
bestWSL <- sqrt(bestFitL[2]**2 + bestFitL[3]**2)
mwdL <- mean(D$WDC, na.rm=TRUE)
mwsL <- mean(D$WSC, na.rm=TRUE)
mtasL <- mean(D$TASX, na.rm=TRUE)
D <- DS		# restore original, then repeat for right turns
D <- D[t2,]
NL <- length(D$GGVEW)
rmsminR <- 1000
n <- 0
# for (n in 9:29) {
#   D$GGVNS <- c(D$GGVNS[(1+n):NL],rep(D$GGVNS[NL],n))
#   D$GGVEW <- c(D$GGVEW[(1+n):NL],rep(D$GGVEW[NL],n))
  wx <- 12.3
  wy <- 13.2
  V <- 154.
  hdg <- D$THDG * Cradeg
  AR <- nlm (csq, c(V, wx, wy, -0.1), D, hessian=TRUE)
  #print(A$estimate)
  VR <- AR$estimate[1]
  wxR <- AR$estimate[2]
  wyR <- AR$estimate[3]
  dhR <- AR$estimate[4]
 #print(sprintf(" wind estimate: %.1f / %.1f", atan2(wyR,wxR)*180/pi+180, sqrt(wxR**2+wyR**2)))
  vxR <- VR * cos(hdg+dhR*Cradeg) + wxR
  vyR <- VR * sin(hdg+dhR*Cradeg) + wyR
  rmsR <- (AR$minimum/length(D$THDG))**0.5
  if (rmsR < rmsmin) {
    rmsminR <- rmsR
    bestFitR <- AR$estimate
    #nbest <- n
#   }
  #print(sprintf("RMS error for shift of %d samples: %5.2f m/s", n, rmsR))
}

# impose best-fit shift nbest units forward in time
# D$GGVNS <- c(D$GGVNS[(1+nbest):NL],rep(D$GGVNS[NL],nbest))
# D$GGVEW <- c(D$GGVEW[(1+nbest):NL],rep(D$GGVEW[NL],nbest))
# best-fit wind:
bestWDR <- (atan2(bestFitR[2], bestFitR[3]) / Cradeg + 180.) %% 360
bestWSR <- sqrt(bestFitR[2]**2 + bestFitR[3]**2)
mwdR <- mean(D$WDC, na.rm=TRUE)
mwsR <- mean(D$WSC, na.rm=TRUE)
mtasR <- mean(D$TASX, na.rm=TRUE)
D <- DS		# restore original

@

<<gs-only-analysis, include=TRUE>>=

D["WS"] <- D$WSC
D["Ang"] <- (D$THDG+(D$SS)*cos(D$ROLL*pi/180)-mwd) %% 360
D["TurnDirection"] <- as.integer(ifelse((D$ROLL > 0),1,2))
DF <- D[c(t1,t2),]
fmx1 <- lm(GGSPD[DF$TurnDirection == 2] ~ sin(AA[DF$TurnDirection == 2]*pi/180)+cos(AA[DF$TurnDirection == 2]*pi/180), data=DF)
cfx1 <- coefficients(fmx1)
fmx2 <- lm(GGSPD[DF$TurnDirection == 1] ~ sin(AA[DF$TurnDirection == 1]*pi/180)+cos(AA[DF$TurnDirection == 1]*pi/180), data=DF)
cfx2 <- coefficients(fmx2)
gsdiff1 <- max(D$GGSPD[t1]) - min(D$GGSPD[t1])
gsdiff2 <- max(D$GGSPD[t2]) - min(D$GGSPD[t2])
Z1 <- cfx1[1]+cfx1[2]*sin(DF$AA*pi/180.)+cfx1[3]*cos(DF$AA*pi/180.)
Z2 <- cfx2[1]+cfx2[2]*sin(DF$AA*pi/180.)+cfx2[3]*cos(DF$AA*pi/180.)
gsfdiff1 <- max(Z1) - min(Z1)
gsfdiff2 <- max(Z2) - min(Z2)



@


<<gs-only-plot, fig.lp="fig:", fig.cap="\\textsl{Ground speed (GGSPD) vs the angle of flight relative to the mean wind direction, for the circle pattern shown in Fig.\\ \\ref{fig:CircleFlightPatterns-1}. The dashed orange line represents a fit to a sinusoidal pattern separately for the right-turn and left-turn segments.}", include=TRUE>>=
clr = c("fit", "left", "right")
col = c("darkorange", "blue", "darkgreen")
g <- ggplot(data=DF, aes(x=AA, y=GGSPD))
g <- g + geom_point(data=DF[DF$TurnDirection == 2,],size=2, aes(colour=clr[2],shape=clr[2]))
g <- g + geom_point(data=DF[DF$TurnDirection == 1,],size=2, aes(colour=clr[3],shape=clr[3]))
g <- g + geom_line(aes(y=cfx1[1]+cfx1[2]*sin(DF$AA*pi/180.)+cfx1[3]*cos(DF$AA*pi/180.),  colour=clr[1]), lwd=1, lty=2)
g <- g + geom_line(aes(y=cfx2[1]+cfx2[2]*sin(DF$AA*pi/180.)+cfx2[3]*cos(DF$AA*pi/180.),  colour=clr[1]), lwd=1, lty=2)
g <- g + scale_colour_manual("", labels = clr, values = col)
g <- g + scale_shape_manual ("", guide=FALSE, labels = clr, values = rep(20,3))
g <- g + xlab("Heading - Wind Dir.") + ylab("Ground Speed [m/s]")+theme_WAC()     
g <- g + theme(legend.position=c(0.75,0.94))
g
# plot(AA[t1], D$GGSPD[t1], pch=19, col='blue')
# points(AA[t2], D$GGSPD[t2], pch=19, col='darkgreen')

@

Repeating this analysis for the left-turn circles and right-turn circles
separately reveals a difference in the deduced wind that is about
1.2~m/s, as also listed in Table~\ref{tab:GSmin}:

\begin{center}
\begin{table}[H]
\begin{centering}
\begin{tabular}{cccccc}
\toprule 
 & $\bar{v_{d}}\,[^{\circ}]$ & $\bar{v_{s}}$~{[}m/s{]} & TAS~{[}m/s{]} & $\delta\psi\,[^{\circ}]$ & residual error {[}m/s{]}\tabularnewline
\midrule
\midrule 
all turns & \Sexpr{format(round(bestWD,1), nsmall=1)} & \Sexpr{round(bestWS,1)} & \Sexpr{round(bestFit[1],1)} & \Sexpr{round(bestFit[4],1)} & \Sexpr{format(round(rmsmin,1), nsmall=1)}\tabularnewline
\midrule 
mean of measurements & \Sexpr{format(round(mwd,1), nsmall=1)} & \Sexpr{format(round(mws,1), nsmall=1)} & \Sexpr{round(mtas,1)} &  & \tabularnewline
\midrule 
left turns & \Sexpr{format(round(bestWDL,1), nsmall=1)} & \Sexpr{round(bestWSL,1)} & \Sexpr{round(bestFitL[1],1)} & \Sexpr{round(bestFitL[4],1)} & \Sexpr{format(round(rmsminL,1), nsmall=1)}\tabularnewline
\midrule 
right turns & \Sexpr{format(round(bestWDR,1), nsmall=1)} & \Sexpr{round(bestWSR,1)} & \Sexpr{round(bestFitR[1],1)} & \Sexpr{round(bestFitR[4],1)} & \Sexpr{format(round(rmsminR,1), nsmall=1)}\tabularnewline
\bottomrule
\end{tabular}
\par\end{centering}

\protect\caption{\textsl{The results obtained by minimizing the error measure (\ref{eq:gs-chisq})
for the circle maneuver.}\label{tab:GSmin}}
\end{table}

\par\end{center}

A plausible case can be made for this difference between left-turn
and right-turn circles being real. Figure \ref{fig:gs-only-plot}
shows the GPS-derived measurements of ground speed. The amplitude
of the variation around the circle is smaller for the left-turn circles
vs.~the right-turn circles. (The left-turn circle also does not provide
nearly as good a fit to the assumption of steady wind as does the
right-turn circle.) The difference between maximum and minimum ground
speeds is \Sexpr{round(gsdiff1,1)} m/s for left-turn circles but
\Sexpr{round(gsdiff2,1)} m/s for right-turn circles, indicating a
difference in wind speed of \Sexpr{round((gsdiff1-gsdiff2)/2,1)}
m/s between the two turn directions.%
\footnote{If circles are fitted to the variations, the result is a difference
of \Sexpr{round((gsfdiff1-gsfdiff2)/2,1)} m/s.%
} This difference is determined from the GPS-derived ground-speed measurements
only and doesn't involve any other aspect of the wind-measuring systems
on the aircraft. Even heading or sideslip can be in significant error
without affecting this result for wind speed because the analysis
is based only on the maximum vs.~minimum values of the ground speed.
It is expected from instrument specifications that the measurement
of ground speed is much less uncertain that this, so the suggested
conclusion is that the difference in average wind is real in the regions
where the two circles were flown. This difference also contributes
to the rather large residual error because the combined fit assumes
that a single wind vector characterizes both circles. Figure \ref{fig:gs-only-plot}
is evidence that the right-turn circle provides a more consistent
result, so that turn direction will be emphasized in the following analysis. That circle
indicates that the wind vector is from \Sexpr{format(round(bestWDR,1), nsmall=1)}$^{\circ}$ at \Sexpr{round(bestWSR,1)} m/s and
that there is a heading error of \Sexpr{round(bestFitR[4],1)}$^{\circ}$. A -0.2$^{\circ}$ adjustment in heading, introduced via calibration coefficients, was already made on the basis of a preliminary version of the present study, so this indicates that the heading offset should be reset to zero. However, the angle $\psi$ contains not only any error
in heading but also any error in sideslip, so this result will be refined below where those errors are determined separately.  


<<plotGSRMS2, echo=FALSE, include=FALSE>>=

# define a chisquare error function:
csq3 <- function (x, D) {
  hdg <- (D$THDG+D$SS*cos(D$ROLL*pi/180)+x[4]) * pi / 180.
  dvx <- D$GGVEW - (x[2] + (D$TASX+x[1])*sin(hdg))
  dvy <- D$GGVNS - (x[3] + (D$TASX+x[1])*cos(hdg))
  chisq <- sum (dvx**2 + dvy**2)
}
# # try shifting GGVxxB forward n samples
# rms <- vector("numeric", 29)
GGVEW <- D$GGVEW
GGVNS <- D$GGVNS
NL <- length(D$GGVEW)
rmsmin <- 1000
n = 0
# for (n in 9:29) {
#   D$GGVNS <- c(D$GGVNS[(1+n):NL],rep(D$GGVNS[NL],n))
#   D$GGVEW <- c(D$GGVEW[(1+n):NL],rep(D$GGVEW[NL],n))
  wx <- 12.3
  wy <- 13.2
  dV <- 1.
  hdg <- D$THDG * Cradeg
  A <- nlm (csq, c(dV, wx, wy, -0.1), D, hessian=TRUE)
#   D$GGVEW <- GGVEW
#   D$GGVNS <- GGVNS
    #print(A$estimate)
  dV <- A$estimate[1]
  wx <- A$estimate[2]
  wy <- A$estimate[3]
  dh <- A$estimate[4]
   #print(sprintf(" wind estimate: %.1f / %.1f", atan2(wy,wx)*180/pi+180, sqrt(wx**2+wy**2)))
  vx <- (D$TASX+dV) * cos(hdg+dh*Cradeg) + wx
  vy <- (D$TASX+dV) * sin(hdg+dh*Cradeg) + wy
  rms <- (A$minimum/length(D$THDG))**0.5
  if (rms < rmsmin) {
    rmsmin <- rms
    bestFit <- A$estimate
    #nbest <- n
  }
    #print(sprintf("RMS error for shift of %d samples: %5.2f m/s", n, rms[n]))
# }

# impose best-fit shift nbest units forward in time
# D$GGVNS <- c(D$GGVNS[(1+nbest):NL],rep(D$GGVNS[NL],nbest))
# D$GGVEW <- c(D$GGVEW[(1+nbest):NL],rep(D$GGVEW[NL],nbest))
# best-fit wind:
bestWD <- (atan2(bestFit[2], bestFit[3]) / Cradeg + 180.) %% 360
bestWS <- sqrt(bestFit[2]**2 + bestFit[3]**2)
mwd <- mean(D$WDC, na.rm=TRUE)
mws <- mean(D$WSC, na.rm=TRUE)
mtas <- mean(D$TASX, na.rm=TRUE)

# now repeat this for left turns separately
DS <- D		# save this
D <- D[t1,]	# left turn data only
NL <- length(D$GGVEW)
rmsminL <- 1000
n = 0
# for (n in 9:29) {
#   D$GGVNS <- c(D$GGVNS[(1+n):NL],rep(D$GGVNS[NL],n))
#   D$GGVEW <- c(D$GGVEW[(1+n):NL],rep(D$GGVEW[NL],n))
  wx <- 12.3
  wy <- 13.2
  dV <- 1.
  hdg <- D$THDG * Cradeg
  A <- nlm (csq, c(dV, wx, wy, -0.1), D, hessian=TRUE)
#   D$GGVEW <- GGVEW
#   D$GGVNS <- GGVNS
    #print(A$estimate)
  dVL <- A$estimate[1]
  wxL <- A$estimate[2]
  wyL <- A$estimate[3]
  dhL <- A$estimate[4]
   #print(sprintf(" wind estimate: %.1f / %.1f", atan2(wy,wx)*180/pi+180, sqrt(wx**2+wy**2)))
  vxL <- (D$TASX+dV) * cos(hdg+dh*Cradeg) + wx
  vyL <- (D$TASX+dV) * sin(hdg+dh*Cradeg) + wy
  rmsL <- (A$minimum/length(D$THDG))**0.5
  if (rmsL < rmsminL) {
    rmsminL <- rmsL
    bestFitL <- A$estimate
    #nbest <- n
  }
    #print(sprintf("RMS error for shift of %d samples: %5.2f m/s", n, rms[n]))
# }

# impose best-fit shift nbest units forward in time
# D$GGVNS <- c(D$GGVNS[(1+nbest):NL],rep(D$GGVNS[NL],nbest))
# D$GGVEW <- c(D$GGVEW[(1+nbest):NL],rep(D$GGVEW[NL],nbest))
# best-fit wind:
bestWDL <- (atan2(bestFitL[2], bestFitL[3]) / Cradeg + 180.) %% 360
bestWSL <- sqrt(bestFitL[2]**2 + bestFitL[3]**2)
mwdL <- mean(D$WDC, na.rm=TRUE)
mwsL <- mean(D$WSC, na.rm=TRUE)
mtasL <- mean(D$TASX, na.rm=TRUE)

# now right turns only
D <- DS		# restore this
D <- D[t2,]
NL <- length(D$GGVEW)
rmsminR <- 1000
n = 0
# for (n in 9:29) {
#   D$GGVNS <- c(D$GGVNS[(1+n):NL],rep(D$GGVNS[NL],n))
#   D$GGVEW <- c(D$GGVEW[(1+n):NL],rep(D$GGVEW[NL],n))
  wx <- 12.3
  wy <- 13.2
  dV <- 1.
  hdg <- D$THDG * Cradeg
  A <- nlm (csq, c(dV, wx, wy, -0.1), D, hessian=TRUE)
#   D$GGVEW <- GGVEW
#   D$GGVNS <- GGVNS
    #print(A$estimate)
  dVR <- A$estimate[1]
  wxR <- A$estimate[2]
  wyR <- A$estimate[3]
  dhR <- A$estimate[4]
   #print(sprintf(" wind estimate: %.1f / %.1f", atan2(wy,wx)*180/pi+180, sqrt(wx**2+wy**2)))
  vxR <- (D$TASX+dV) * cos(hdg+dh*Cradeg) + wx
  vyR <- (D$TASX+dV) * sin(hdg+dh*Cradeg) + wy
  rmsR <- (A$minimum/length(D$THDG))**0.5
  if (rmsR < rmsminR) {
    rmsminR <- rmsR
    bestFitR <- A$estimate
    #nbest <- n
  }
    #print(sprintf("RMS error for shift of %d samples: %5.2f m/s", n, rms[n]))
# }

# impose best-fit shift nbest units forward in time
# D$GGVNS <- c(D$GGVNS[(1+nbest):NL],rep(D$GGVNS[NL],nbest))
# D$GGVEW <- c(D$GGVEW[(1+nbest):NL],rep(D$GGVEW[NL],nbest))
# best-fit wind:
bestWDR <- (atan2(bestFitR[2], bestFitR[3]) / Cradeg + 180.) %% 360
bestWSR <- sqrt(bestFitR[2]**2 + bestFitR[3]**2)
mwdR <- mean(D$WDC, na.rm=TRUE)
mwsR <- mean(D$WSC, na.rm=TRUE)
mtasR <- mean(D$TASX, na.rm=TRUE)

D <- DS
rm (GGVEW, GGVNS)

@

<<getRMS2, echo=FALSE>>=

hdg <- (D$THDG+bestFit[4])*Cradeg
vx <- bestFit[1] * cos(hdg) + bestFit[2]   
vy <- bestFit[1] * sin(hdg) + bestFit[3]
gs <- sqrt(D$GGVEW**2+D$GGVNS**2)
vs <- sqrt(vx**2+vy**2)
rmsgs <- (sum((gs-vs)**2)/length(gs))**0.5

@

The preceding fit used a constant true airspeed, but it is also possible
to fit in the same way for an assumed error in true airspeed, by using
$V=V_{m}+\delta V$ where $V_{m}$ is the measured value and $\delta V$
is an assumed error in that measurement. There is some small variation
in measured true airspeed during the maneuver, perhaps created by
the normal oscillation that results from the flight management system,
so this approach may be preferable. However, the resulting best-fit
values were very close to those shown in Table~\ref{tab:GSmin}.


\paragraph{Offsets in TAS and heading}

An alternate way of determining the offsets in airspeed and heading,
which illustrates the value of the circle maneuver for developing
these constraints, is to plot the dependence of measured wind speed
$v_{s}$ on the heading. The expected variation is for $v_{s}$ to
change by $2\delta V$ from upwind to downwind flight and by $2V\delta\psi$
from crosswind-right to crosswind-left flight direction (i.e., 90$^{\circ}$
right of downwind vs.~90$^{\circ}$ left). The net effect is to produce
a variation in $v_{s}$ given by:

\begin{equation}
v_{s}=\bar{v_{s}}+\delta V\cos\gamma+V\delta\psi\sin\gamma\label{eq:SinCosDep}
\end{equation}
where $\gamma$ is the difference between the heading and the wind
direction. Figure \ref{fig:sine-cosine-plot} illustrates the expected
dependence that would result from errors of $\delta V$ = 1~m/s and
$\delta\psi=0.3^{\mbox{\ensuremath{\circ}}}$. The plot is constructed
so that $0^{\circ}$ corresponds to downwind flight and the difference
between values at 0 and 180$^{\circ}$corresponds to $2\delta V$,
while the difference from $90$ to 270$^{\circ}$ represents $2V\delta\psi$. 

<<sine-cosine-plot, fig.lp="fig:", fig.cap="\\textsl{Predicted dependence of measured wind speed on direction of flight relative to the wind direction, for assumed errors of $\\delta V=1$ m/s and $\\delta\\psi=0.3^{\\circ}$.}", include=TRUE>>=

op <- par (mfrow=c(1,1), mar=c(4,4,0,2)+0.1)
A1 <- 1.
A2 <- mtas*0.3*pi/180.
Ang <- (1:1440)/4.
plot(Ang, A2*sin(Ang*pi/180.)+A1*cos(Ang*pi/180.) + bestWS, type='l', col='darkorange', lwd=4, xlab="heading minus WD", ylab="Measured WS [m/s]", xlim=c(0.,400.))
#title("Simulation")
text(90.,bestWS, labels=expression(paste(2,V,delta,psi)),cex=0.75)
#lines(c(180.,180.), c(bestWS+0.2, bestWS+1), col='red', lwd=2)
#lines(c(180.,180.), c(bestWS-0.2, bestWS-1), col='red', lwd=2)
arrows(90.,bestWS+0.2,90.,bestWS+A2,length=0.2, col='red', lwd=2)
arrows(90.,bestWS-0.2,90.,bestWS-A2,length=0.2, col='red', lwd=2)
text(180.,bestWS, labels=expression(paste(2,delta,V)), cex=0.75)
#lines(c(180.,180.), c(bestWS+0.2, bestWS+A1), col='red', lwd=2)
#lines(c(180.,180.), c(bestWS-0.2, bestWS-A1), col='red', lwd=2)
arrows(180.,bestWS+0.2,180.,bestWS+A1,length=0.2, col='red', lwd=2)
arrows(180.,bestWS-0.2,180.,bestWS-A1,length=0.2, col='red', lwd=2)
lines(c(0.,360.),c(bestWS+A1,bestWS+A1), col='blue',lty=2,lwd=0.7)
lines(c(0.,360.),c(bestWS-A1,bestWS-A1), col='blue',lty=2,lwd=0.7)
lines(c(0.,360.),c(bestWS+A2,bestWS+A2), col='darkgreen',lty=2,lwd=0.7)
lines(c(0.,360.),c(bestWS-A2,bestWS-A2), col='darkgreen',lty=2,lwd=0.7)

@

<<sine-fit, include=FALSE>>=
D$WS <- D$WSC
D$Ang <- ((D$THDG+(D$SSLIP)*cos(D$ROLL*pi/180)-mwd) %% 360) * pi / 180
# left turns:
rs <- setRange(D$Time, startL, endL)
DF <- D[rs,]
## DF["Ang"] <- Ang[rs]
## DF["WS"] <- WS[rs]
fm1 <- lm (WS~I(sin(Ang))+I(cos(Ang)), data=DF)
cf1 <- coefficients(fm1)
## print(cf1)
# right turns
rsr <- setRange(D$Time, startR, endR)
DF <- D[rsr,]
## DF["Ang"] <- Ang[rsr]
## DF["WS"] <- WS[rsr]
fm2 <- lm (WS~I(sin(Ang))+I(cos(Ang)), data=DF)
cf2 <- coefficients(fm2)
## print(cf2)
## sprintf("dV=%f, dH=%f", cf2[3], cf2[2]/(mtas*pi/180))

@

It is then possible to determine $\delta V$ and $\delta\psi$ by
fitting (\ref{eq:SinCosDep}) to observations. The measurements will
be shown separately for the left-turn circles and the right-turn circles
because there is a difference between them. Figures~\ref{fig:left-turn-circles}
and \ref{fig:right-turn-circles} show the measurements, and the results
of the fits are shown in Table \ref{tab:SinCosCoefficients}. 
The plots do show a sinusoidal pattern as expected
from Fig.~\ref{fig:sine-cosine-plot}, but there is significant scatter. For the more reliable
case shown in Fig.~\ref{fig:right-turn-circles}, the total
standard deviation in measured wind speed is about \Sexpr{round(sd(DF$WS),1)}\,m/s, indicating
an uncertainty limit within that range, but the weak sinusoidal pattern also indicates the presence of systematic error. The fit indicates that the
error in true airspeed is about \Sexpr{round(cf2[3],1)}\,m/s and the error in heading is
about \Sexpr{round(cf2[2]/(mtas*pi/180),2)}$^{\circ}$ after adding the measured sideslip (using first-coefficient 1.5 for sideslip, following the indication from the second reverse-heading maneuver).

\begin{table}
\noindent \begin{centering}
\begin{tabular}{ccccc}
\toprule 
 & mean wind {[}m/s{]} & $\delta V$~{[}m/s{]} & $\delta\psi^{\prime}\,[^{\circ}]$ & residual error {[}m/s{]}\tabularnewline
\midrule
\midrule 
left-turn circles & \Sexpr{format(round(cf1[1],1), nsmall=1)} & \Sexpr{format(round(cf1[3],1), nsmall=1)} & \Sexpr{format(round(cf1[2]/(mtas*pi/180.),2), nsmall=2)} & \Sexpr{round(summary(fm1)$sigma,2)}\tabularnewline
\midrule 
right-turn circles & \Sexpr{format(round(cf2[1],1), nsmall=1)} & \Sexpr{format(round(cf2[3],1), nsmall=1)} & \Sexpr{format(round(cf2[2]/(mtas*pi/180.),2), nsmall=2)} & \Sexpr{round(summary(fm2)$sigma,2)}\tabularnewline
\bottomrule
\end{tabular}
\par\end{centering}

\protect\caption{\textsl{Fit results for the left-turn and right-turn circles as fitted by
(\ref{eq:SinCosDep}). The angle $\delta\psi^{\prime}$, referred to as the heading error, is actually a combination of heading and sideslip error as given by Eq.\ \ref{eq:dpsiprime}. See revised values later in Table\ \ref{tab:Fit-results}, where the heading error is separated from the sideslip error.}\label{tab:SinCosCoefficients}}
\end{table}

Sensitivity tests, in which a fixed offset was added first to TASX and then to THDG, showed that adjustments had the expected results: Addition of the negative of the indicated errors resulted in revised estimates near zero. This indicates that, despite the large deviations from the sinusoidal pattern in the wind (as shown in Fig.\ \ref{fig:right-turn-circles}, esp.\ near the 270$^{\circ}$ direction), the fit results have the expected dependence on error in the true airspeed or heading.

<<left-turn-circles, fig.lp="fig:", fig.cap="\\textsl{Measured wind speed from the left-turn circles in the circle pattern shown in Fig.\\ \\ref{fig:CircleFlightPatterns-1}, as a function of the difference between the heading and the mean wind direction.}", include=TRUE>>=

clr = c("fit", "measurements", "fit")
col = c("darkorange", "blue", "darkorange")
DF <- D[rs,]
g <- ggplot(data=DF, aes(x=Ang*180/pi, y=WS))
g <- g + geom_point(colour=col[2], size=2, aes(shape="measurements")) 
g <- g + geom_line(aes(y=cf1[1]+cf1[2]*sin(DF$Ang)+cf1[3]*cos(DF$Ang),  colour=clr[1]), lwd=3)
g <- g + scale_colour_manual("", labels = clr, values = col)
g <- g + scale_shape_manual ("", labels="measurements", values=19)
g <- g + xlab("Heading - Wind Dir.") + ylab("Wind Speed [m/s]")+theme_WAC()     
g <- g + theme(legend.position=c(0.7,0.94))
print(g)
#plot (Ang[rs], WS[rs], pch=19, col='blue')
#lines(c(180,180), c(0.,50.), col='red', lwd=2)
#lines(c(0,0), c(0.,50.), col='red', lwd=2)
#lines(c(90,90), c(0.,50.), col='red', lwd=2)
#lines(c(270,270), c(0.,50.), col='red', lwd=2)
#lines(c(360,360), c(0.,50.), col='red', lwd=2)
#lines(Ang[rs], cf1[1]+cf1[2]*sin(Ang[rs]*pi/180.)+cf1[3]*cos(Ang[rs]*pi/180.), col='darkorange', lwd=4)

@

<<right-turn-circles, fig.lp="fig:", fig.cap="\\textsl{As for Fig.\\ \\ref{fig:left-turn-circles} but for the right-hand circles.}", include=TRUE>>=

clr = c("fit", "measurements", "fit")
col = c("darkorange", "darkgreen", "darkorange")
DF <- D[rsr,]
g <- ggplot(data=DF, aes(x=Ang*180/pi, y=WS))
g <- g + geom_point(colour=col[2], size=2, aes(shape="measurements")) 
g <- g + geom_line(aes(y=cf2[1]+cf2[2]*sin(DF$Ang)+cf2[3]*cos(DF$Ang),  colour=clr[1]), lwd=3)
g <- g + scale_colour_manual("", labels = clr, values = col)
g <- g + scale_shape_manual ("", labels="measurements", values=19)
g <- g + xlab("Heading - Wind Dir.") + ylab("Wind Speed [m/s]")+theme_WAC()     
g <- g + theme(legend.position=c(0.25,0.94))
g
#plot (Ang[rs], WS[rs], pch=19, col='blue')
#lines(c(180,180), c(0.,50.), col='red', lwd=2)
#lines(c(0,0), c(0.,50.), col='red', lwd=2)
#lines(c(90,90), c(0.,50.), col='red', lwd=2)
#lines(c(270,270), c(0.,50.), col='red', lwd=2)
#lines(c(360,360), c(0.,50.), col='red', lwd=2)
#lines(Ang[rs], cf2[1]+cf2[2]*sin(Ang[rs]*pi/180.)+cf2[3]*cos(Ang[rs]*pi/180.), col='darkorange', lwd=4)

@


\paragraph{Offset in Sideslip\label{par:Offset-in-Sideslip}}

In the preceding, the error $\delta\psi$ was discussed as an error
in heading, but the error could also be one in sideslip. These errors
are difficult to separate and normal reverse-heading maneuvers do
not provide a separation. Furthermore, heading errors likely change
during a flight because error terms undergo a Schuler oscillation
and are also affected by horizontal accelerations such as occur persistently
in turns like those in the circle maneuver. The error term determined
as in the above tables is $\delta\psi^{\prime}$ given by

\begin{equation}
\delta\psi^{\prime}=\delta\psi+\cos\phi\delta\beta\label{eq:dpsiprime}
\end{equation}
where $\phi$ is the roll angle and $\delta\beta$ is the offset in
sideslip. The sideslip calibration initially was determined 
from yaw maneuvers, but those maneuvers also cannot separate an offset
in heading from an offset in sideslip so the first coefficient in
the calibration, representing the zero offset, is not constrained
well by these maneuvers. Because the dependence in (\ref{eq:dpsiprime})
is on the cosine of the roll which is an even function, left and right
turns are affected in the same way and cannot distinguish the two
terms in the equation.

Two approaches could be taken. Because the roll angle changes when
circles are flown at different altitudes, results from different-altitude
circles could be used to distinguish a sideslip offset from a heading
offset. Perhaps a more straightforward test, though, is to compare
the sideslip measurement in left vs right turns. In these two cases,
some sideslip is introduced as the aircraft configuration remains
slightly nose-up during the turn, and that sideslip should reverse
sign by symmetry. The lift required to maintain altitude would be
the same if the roll angles were opposite, as they nearly are for
these maneuvers (1.46$^{\circ}$ larger for right turns), and the
angle of attack is also close to the same, so the expected sign reversal
in sideslip can be used to determine the offset in sideslip. The measurements
of sideslip 
are shown in Fig.~\ref{fig:plotSS}. The red dashed line shows the
indicated offset (-0.11$^{\circ}$) that is required if the two turn
directions are to have the same magnitude of sideslip. Because
1.5$^{\circ}$ was already used as the constant coefficient in sideslip
calibration, this indicates that the best value of the first calibration coefficient ($e_0$ in Eq.\ \ref{eq:betaFunctionForm}) is 1.61; i.e., the resulting
sensitivity coefficients for sideslip should be \{$e_{o},\, e_{1}$\}
= \{1.61, \Sexpr{round(cfs[2], 3)}\}. The estimated standard uncertainty in the first
coefficient is about 0.1 on the basis of differences among the various
estimates of this coefficient and on the basis of uncertainty in the
heading measurement on which some of these calibration methods depend.
The uncertainty in the second coefficient, estimated from the standard
uncertainty with which the slope could be determined in Fig.~2, is
about 0.04, 

<<plotSS, fig.lp="fig:", fig.cap = "\\textsl{Measurement of sideslip during the circle maneuver from FRAPPE flight 9, with left-turn circles from 19:19:36 -- 19:22:28 UTC, followed by a straight segment and then right-turn circles 19:23:08 -- 19:26:02 UTC.}", include=TRUE>>=

Capn <- "Sideslip measured turning the circle maneuvers, first turning left (19:19:36 -- 19:22:28) and then turning right (19:23:08 -- 19:26:02). Mean values for these segments are indicated by dashed orange lines."
Z <- plotWAC(D$Time, D$SS, ylab="Sideslip")
lines(c(D$Time[1], D$Time[length(D$Time)]), c(-0.11,-0.11), col='red', lty=2, lwd=4)
yr <- mean(D$SS[setRange(D$Time,191936,192228)])
lines(c(D$Time[getIndex(D$Time,191936)], D$Time[getIndex(D$Time, 192228)]), c(yr,yr), col='darkorange', lty=2, lwd=4)
yr <- mean(D$SS[setRange(D$Time, 192308,192602)])
lines(c(D$Time[getIndex(D$Time,192308)], D$Time[getIndex(D$Time, 192602)]), c(yr,yr), col='darkorange', lty=2, lwd=4)
#title(main=' ', sub="add 0.11 deg. to SSLIP to correct for offset", cex.sub=0.7)

@

 

<<combined-circles, fig.lp="fig:", fig.cap="\\textsl{Wind speed as a function of heading relative to the wind direction, with a fit to the combined data set shown.}", include=TRUE, fig.align='center'>>=

# combined left and right turns
rs <- c(setRange(D$Time,191936,192228),setRange(D$Time, 192308, 192602))
DF <- D[rs,]
fmc <- lm (WS~sin(Ang)+cos(Ang), data=DF)
cfc <- coefficients(fmc)

clr = c("fit", "left", "right")
col = c("darkorange", "blue", "darkgreen")
g <- ggplot(data=DF, aes(x=Ang*180/pi, y=WS))
g <- g + geom_point(data=DF[DF$TurnDirection == 2,],size=2, aes(colour=clr[2],shape=clr[2]))
g <- g + geom_point(data=DF[DF$TurnDirection == 1,],size=2, aes(colour=clr[3],shape=clr[3]))
g <- g + geom_line(aes(y=cfc[1]+cfc[2]*sin(DF$Ang)+cfc[3]*cos(DF$Ang),  colour=clr[1]), lwd=3)
g <- g + scale_colour_manual("", labels = clr, values = col)
g <- g + scale_shape_manual ("", guide=FALSE, labels = clr, values = rep(20,3))
g <- g + xlab("Heading - Wind Dir.") + ylab("Wind Speed [m/s]")+theme_WAC()     
g <- g + theme(legend.position=c(0.75,0.94))
g

# get value for equation below:
rmeanL <- mean(DF$ROLL[DF$TurnDirection == 2])
rmeanR <- mean(DF$ROLL[DF$TurnDirection == 1])
tasmL <- mean(DF$TASX[DF$TurnDirection == 2])
tasmR <- mean(DF$TASX[DF$TurnDirection == 1])
#print (c(rmeanL, rmeanR))
#print(sprintf(" left turns: mean TAS = %.2f, ROLL = %.2f, right turns %.2f %.2f", tasmL, rmeanL, tasmR, rmeanR))
dv <- 0.5*mean(DF$TASX)*tan(rmeanR*pi/180)*(rmeanR+rmeanL)*pi/180
#print (sprintf(" predicted TAS difference is %.2f", dv))
## this predicts faster flight in the right-turn circle, contrary
## to observations. ??

@

With this shift applied, the dependence of the wind speed on flight direction for the combined left-turn and right-turn
circles is shown in Fig.~\ref{fig:combined-circles}. The best-fit coefficients are as shown in Table~\ref{tab:Fit-results},
where the values for left-turn-only and right-turn-only measurements
are repeated and shown with the results from both circles combined.

\noindent \begin{center}
\begin{table}
\noindent \centering{}%
\fbox{\begin{minipage}[t]{1\columnwidth}%
\noindent \begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline 
 & mean wind {[}m/s{]} & $\delta V$~{[}m/s{]} & $\delta\psi\,[^{\circ}]$ & residual error {[}m/s{]}\tabularnewline
\hline 
\hline 
left-turn circles & \Sexpr{round(cf1[1],1)} & \Sexpr{format(round(cf1[3],1), nsmall=1)} & \Sexpr{format(round(cf1[2]/(mtas*pi/180.)+0.11*cos(27*pi/180),2), nsmall=2)} & \Sexpr{round(summary(fm1)$sigma,2)}\tabularnewline
\hline 
right-turn circles & \Sexpr{round(cf2[1],1)} & \Sexpr{format(round(cf2[3],1), nsmall=1)} & \Sexpr{format(round(cf2[2]/(mtas*pi/180.)+0.11*cos(27*pi/180),2), nsmall=2)} & \Sexpr{round(summary(fm2)$sigma,2)}\tabularnewline
\hline 
combined & \Sexpr{round(cfc[1],1)} & \Sexpr{format(round(cfc[3],1), nsmall=1)} & \Sexpr{format(round(cfc[2]/(mtas*pi/180.)+0.11*cos(27*pi/180),2), nsmall=2)} & \Sexpr{round(summary(fmc)$sigma,2)}\tabularnewline
\hline 
\end{tabular}
\par\end{center}

\protect\caption{\textsl{Fit results for errors in true airspeed $V$ and heading $\psi$ and
the residual errors for the fits of Eq.~\vref{eq:SinCosDep} to
the circles.}\label{tab:Fit-results} }
%
\end{minipage}}
\end{table}

\par\end{center}


\section{Recommendations, angle of attack, sideslip, heading, and true airspeed}


\subsection{Sensitivity coefficients:}

The coefficients in Table~\ref{tab:SensCoef} include all adjustments
discussed in this memo and should be the best to use for FRAPPE, provided that the dynamic pressure measurement QCFR is used in the equations for calculating angle-of-attack and sideslip from ADIFR and BDIFR. The
coefficients are dependent on the accuracy of the attitude angles
provided by the IRU and will be changed in cases where the pitch or
heading aligns differently or otherwise develops errors different
from those at the time these coefficients were determined. Both angles
have uncertainty of about 0.05$^{\circ}$, so that contributes to the
uncertainty in results from these fits.

\noindent \begin{center}
\begin{table}
\noindent \centering{}%
\Ovalbox{\begin{minipage}[t]{1\columnwidth}%
\noindent \begin{center}
\begin{tabular}{ccc}
\toprule 
\textbf{angle} & $c_{0}$ & $c_{1}$\tabularnewline
\midrule
\midrule 
AKRD & \Sexpr{format(round(cfr[1],3), nsmall=3)} & \Sexpr{format(round(cfr[2],3), nsmall=3)}\tabularnewline
\midrule 
SSRD & \Sexpr{format(round(cfs[1]+0.11,3), nsmall=3)} & \Sexpr{format(round(cfs[2],3), nsmall=3)}\tabularnewline
\bottomrule
\end{tabular}
\par\end{center}

\protect\caption{\textsl{Recommended sensitivity coefficients for the C-130 in FRAPPE.}\label{tab:SensCoef}}
%
\end{minipage}}
\end{table}

\par\end{center}


\subsection{Pressure corrections for the static defect}

With the angle of attack determined as in Table~\vref{tab:SensCoef},
the formula for C-130 pressure corrections that was previously determined
should remain valid. The formulas for PSFD, QCF, PSFRD, and QCFR are
given with Eq.~\vref{eq:PCOReq2} of this memo.

\subsection{GPS timing}

The time shift for variables like GGVEW/GGVNS should be -1540 instead of -2000.

\subsection{Corrections to TAS, sideslip, and heading ($V,\,\beta,\,\psi):$}

No corrections are needed except that for sideslip (already incorporated into the coefficients in Table\ \ref{tab:SensCoef}) and perhaps a minor change in the heading offset (below). The results from the circle maneuver analyzed here are summarized
in Table~\ref{tab:CircleCorrections}. The indicated quantities are errors, so correction terms would be the negative of these errors. The right-turn circle maneuver,
which appears to be in more steady conditions than the left-turn circle and is therefore the basis for these recommendations,
indicates that the airspeed may need adjustment by -\Sexpr{round(cf2[3],1)}\,m/s. This
is small enough and still has uncertainty of about 0.2\,m/s, because the conditions during
this circle maneuver were not as steady as desirable, so it appears
preferable to make no further correction to the true airspeed. 
The heading correction of \Sexpr{format(round((cf2[2]/(mtas*pi/180.)+0.11*cos(27*pi/180)),2), nsmall=2)} is also quite small, and the analysis was done on a data file where the assumed calibration coefficients for heading were \{-0.2, 1.0\}, so the indication here is that these calibration coefficients should either be changed to \{-0.1, 1.\} or \{0.,1.\}. Because the different ways of determining this heading offset produced answers that varied by about 0.1$^{\circ}$, it may be best to change the heading offset to -0.1 and consider the uncertainty to be about of this magnitude. 

\noindent \begin{center}
\begin{table}
\noindent \centering{}%
\Ovalbox{\begin{minipage}[t]{1\columnwidth}%
\noindent \begin{center}
\begin{tabular}{cccc}
\toprule 
\textbf{type} & \textbf{true airspeed error $\delta V$ {[}m/s{]}} & \textbf{sideslip error $\delta\beta$ {[}$^{\circ}${]}}%
\footnote{included in Table \ref{tab:SensCoef} above for SSRD%
} & \textbf{heading error $\delta\psi$ {[}$^{\circ}${]}}\tabularnewline
\midrule
\midrule 
left-turn & \Sexpr{format(round(cf1[3],1),nsmall=1)} & -0.11 & \Sexpr{format(round(cf1[2]/(mtas*pi/180.)+0.11*cos(27*pi/180),2), nsmall=2)}\tabularnewline
\midrule 
\textsl{\textcolor{red}{right-turn}} & \textsl{\textcolor{red}{\Sexpr{format(round(cf2[3],1),nsmall=1)}}} & \textsl{\textcolor{red}{-0.11}} & \textsl{\textcolor{red}{\Sexpr{format(round(cf2[2]/(mtas*pi/180.)+0.11*cos(27*pi/180),2), nsmall=2)}}}\tabularnewline
\midrule 
combined & \Sexpr{format(round(cfc[3],1),nsmall=1)} & -0.11 & \Sexpr{format(round(cfc[2]/(mtas*pi/180.)+0.11*cos(27*pi/180),2), nsmall=2)}\tabularnewline
\bottomrule
\end{tabular}
\par\end{center}

\protect\caption{\textsl{Angle and airspeed adjustments suggested from the circle maneuver
of FRAPPE flight~9, 19:19--19:27 UTC. The highlighted results from
the right turn appear to be more reliable than those from the left
turn or the combined results because conditions were more uniform
around the right-turn circle.}\label{tab:CircleCorrections}}
%
\end{minipage}}
\end{table}

\par\end{center}

\noindent \begin{center}

\par\end{center}



\begin{center}
\textsf{\textcolor{blue}{-- End of Memo --\vfill\eject}}
\par\end{center}

\textbf{Reproducibility:}

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & \Sexpr{thisFileName}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \Sexpr{thisFileName}.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \Sexpr{thisFileName}.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & /scr/raf/cooperw/\Sexpr{Project}/\Sexpr{Flight}R.nc, /scr/raf/cooperw/FRAPPErf04R.nc \tabularnewline
\textsf{\textsc{\textcolor{blue}{nimbus configuration file:}}} & /scr/raf/cooperw/\Sexpr{Project}RHa (high rate) \tabularnewline
\textsf{\textsc{\textcolor{blue}{Archived Subset Data:}}} & FRAPPErf09R.Rdata, FRAPPErf04R.Rdata \tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & git@github.com:WilliamCooper/\Sexpr{Project}.git\tabularnewline
\end{tabular}

\attachm{\Sexpr{thisFileName}.Rnw\\\Sexpr{thisFileName}.pdf\\FRAPPErf04R.Rdata\\FRAPPErf09R.Rdata\\FRAPPERHa\\SessionInfo}
%\cc{first attachment\\second\\3rd att}
%\attach{attachment}
%\attachm{first\\second} %\cc{first attachment\\second\\3rd att}

<<get-cal-coefs>>=
MQCFR <- system(sprintf("ncdump -h %s%s/%s%sR.nc | grep 'QCFR:Cal'", DataDirectory(), Project, Project, Flight), intern=TRUE)
MQCF <- system(sprintf("ncdump -h %s%s/%s%sR.nc | grep 'QCF:Cal'", DataDirectory(), Project, Project, Flight), intern=TRUE)
MADIFR <- system(sprintf("ncdump -h %s%s/%s%sR.nc | grep 'ADIFR:Cal'", DataDirectory(), Project, Project, Flight), intern=TRUE)
MBDIFR <- system(sprintf("ncdump -h %s%s/%s%sR.nc | grep 'BDIFR:Cal'", DataDirectory(), Project, Project, Flight), intern=TRUE)
MTHDG <- system(sprintf("ncdump -h %s%s/%s%sR.nc | grep 'THDG:Cal'", DataDirectory(), Project, Project, Flight), intern=TRUE)
@


\noindent Some relevant cal coefficients in netCDF files used:\\
\Sexpr{MQCFR}\\\Sexpr{MADIFR}\\\Sexpr{MBDIFR}\\\Sexpr{MTHDG}\\\Sexpr{MQCF}

<<save-system-info, echo=FALSE>>= 
cat (toLatex(sessionInfo()), file="SessionInfo")

@ 
<<make-zip-archive, echo=TRUE, INCLUDE=TRUE>>=
system (sprintf("zip %s.zip %s.Rnw %s.pdf FRAPPErf04R.Rdata FRAPPErf09R.Rdata FRAPPERHa SessionInfo", thisFileName, thisFileName, thisFileName))

@ 



%\cc{first attachment\\second\\3rd att}
\end{document}
